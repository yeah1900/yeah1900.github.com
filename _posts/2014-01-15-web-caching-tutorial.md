---
layout: post
title: "Web Caching Tutorial"
description: ""
category: 
tags: []
---

本文为[Caching Tutorial for Web Authors and Webmasters](http://www.mnot.net/cache_docs/)的阅读笔记，并非全文对照翻译。

使用Web缓存的目的主要是：

 * 减少网络延迟 (因为响应来自相对更接近请求者的地方，网络延迟相对也较小)
 * 减少网络流量

根据缓存储存地方，可以将Web缓存分为：

 * 浏览器缓存
 * 代理缓存
 * 网关缓存（又称反向代理缓存）。和代理缓存的区别在于：代理缓存离实际用户更近，影响用户范围相对较小；网关位于实际服务器之前，通常有服务器管理员设定，面向更多的用户，CDN就是一个例子。

# Web缓存是如何工作的？

以下是几条关于缓存的重要原则：
 
 1. 如果HTTP响应头明确说明不需要缓存该资源，不缓存。
 2. ~~不缓存HTTPS资源。~~（[HTTPS资源现在已经能被浏览器缓存了](http://stackoverflow.com/questions/174348/will-web-browsers-cache-content-over-https)）
 3. 一个浏览器缓存只有满足以下条件才会被认为是“新鲜”（fresh）的：
   - 被设定了过期时间（或类似的条件），并且在这个时间范围内	
   - *If the cache has seen the representation recently, and it was modified relatively long ago.*(不知道该如何翻译)

   缓存是“新鲜”的意味着，浏览器可以直接使用，而不再需要发送请求到服务器验证其是否有效。
 4. 如果缓存已“过期”，需要请求服务器来验证有该资源的有效性。
 5. 在一些特定条件下，如离线状态下，“已过期”的缓存可以不做服务器验证直接被浏览器使用。

这里提到了缓存的两个属性：“新鲜度”（freshness）和“有效性”（validation）。不“新鲜”的缓存需要连接服务器来验证有效性，如果这个资源在服务器没有发生变化，那服务器就会认定这个缓存仍然是“有效”的，也就不需要把整个资源再发送过来了。

# 如何控制缓存？ 

## 使用HTTP响应头：```Expires```设置缓存的过期时间

在Expires中设置的是HTTP时间，即标准时间，而非本地时间。浏览器认为本地缓存在这个时间之前都是“新鲜”的，不需要连接服务器做验证。

```
Expires: Fri, 30 Oct 1998 14:19:41 GMT
```

但由于它基于是绝对时间，而且是基于服务器上的时间来确定的，因此当用户机器和服务器上的标准时间不一致时，缓存也许不会如期望般工作。

## HTTP响应头：```Cache-Control```

HTTP 1.1引入了```Cache-Control```的HTTP响应头，提供了更多控制缓存的方式。[HTTP 1.1协议文档](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.1)对这一部分有详细阐述。

**内容以什么方式缓存**

- ```public``` 表明响应可以被缓存在任何地方（终端浏览器，代理服务器）。
- ```private``` 表明该响应只对单个用户有效，不需要存放在共享缓存，因此代理服务器可以不缓存这个响应。
- ```no-cache``` 表明每次向用户提供缓存时都需要连接服务器验证缓存的有效性

**是否需要缓存**

- ```no-store``` 表明不缓存这个响应

**缓存的过期时间**

- ```max-age=[seconds]``` 指定了缓存会在多长时间能保持“新鲜”。
- ```s-maxage=[seconds]``` 和```max-age```类似，但仅对共享缓存有效

**缓存验证**

- ```must-revalidate``` 前面提到，HTTP协议允许在一些特殊情况（如离线状态）下使用已过期的缓存。但如果在响应中指定了这个值，对应的缓存一旦过期就被强制必须向服务器验证之后才能使用。它和```no-cache```很像，区别在于no-cache下的缓存永远都是过期的。
- ```proxy-revalidate``` 和```must-revalidate```类似，但仅对共享缓存有效

例子：

```
Cache-Control: max-age=3600, must-revalidate
```

在```max-age```和```Expires```同时存在的情况下，前者优先级更高。

## 缓存的验证

要向服务器验证本地缓存的有效性，需要提供这个资源的“版本信息”。HTTP协议实现了两种方式：

- 服务器在响应中添加```Last-Modified```头表明资源的最后修改时间。在验证时，客户端通过```If-Modified-Since```头将其发送给服务器。
- 服务器为每个需缓存的资源生成唯一标识符，资源发生改变它也会跟着改变。服务器会将其放在```ETag```这个响应头中，相应的，客户端会在验证时把它放在```If-None-Match```请求头里。

大多数Web服务器会同时采取这两种方式。

## 如何在创建网站时充分利用缓存机制

- “缓存金律”—— 同一个资源始终使用相同的URL
- 为不经常改变的资源设定一个较远的过期时间
- 为每隔固定时间发生改变的资源设定一个合理的过期时间
- 要使改动的资源尽快生效，可以采用改名的方式。这样你可以放心地为它设置一个相对远的过期时间。
- 避免不小心修改缓存的资源 —— 如更新网站内容时，不要拷贝整个目录结构
